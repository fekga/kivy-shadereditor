{"shader": {"fragment": "uniform float time;\nuniform vec2 resolution;\nuniform vec2 mouse;\n\nconst float pi = 3.141569;\nconst float pi2 = pi*2.;\nconst float pi_2 = pi/2.;\n\n#define min3(a,b,c) min(a,min(b,c))\n#define sin1(a) (sin(a)*.5+.5)\n#define cos1(a) (cos(a)*.5+.5)\n#define saw1(x) (abs(fract(x)*2.-1.)\n#define saw(x)  (abs(fract(x)*4.-2.)-1.)\n\nvec2 c_mul (vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+b.x*a.y);\n}\n\nvec2 c_conj (vec2 a)\n{\n    return vec2(a.x, -a.y);\n}\n\nvec2 c_inv (vec2 a)\n{\n    return c_conj(a) / dot(a, a);\n}\n\nvec2 c_div (vec2 a, vec2 b)\n{\n    return mat2(a,a.y,-a.x)*b/dot(b,b);\n}\n\nvec2 c_exp (vec2 a)\n{\n    return exp(a.x)*vec2(cos(a.y),sin(a.y));\n}\n\nvec2 tr(vec2 p)\n{\n    p/=resolution.xy;\n    p=-1.+2.*p;\n    p.x *=resolution.x/resolution.y;\n    return p;\n}\n\nfloat hash( float n )\n{\nreturn fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x )\n{\nvec2 p = floor(x);\nvec2 f = fract(x);\nf = f*f*(3.0-2.0*f);\nfloat n = p.x + p.y*157.0;\nreturn mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\nmix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p )\n{\nfloat f = 0.0;\nf += 0.5000*noise( p ); p = m2*p*2.02;\nf += 0.2500*noise( p ); p = m2*p*2.03;\nf += 0.1250*noise( p ); p = m2*p*2.01;\nf += 0.0625*noise( p );\nreturn f/0.9375;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nmat2 rot(float a)\n{\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvec2 F(vec2 p)\n{\n    p = c_mul(p,vec2(.0,1.));\n    return (c_exp(p) - c_exp(-p)*.5);\n}\n\nvec2 dF(vec2 p)\n{\n    p = c_mul(p,vec2(.0,1.));\n    return (c_exp(p) + c_exp(-p)*.5);\n}\n\nvec3 fractal(vec2 z, vec2 p, float iter)\n{\n    float i = .0;\n    for(i=.0;i<iter;i++)\n    {\n        z = z - c_div(F(z), dF(z));\n        if (length(F(z)) < 1e-5)\n            break;\n    }\n\n    return vec3(z,i/iter);\n}\n\nvoid main( void )\n{\n    vec2 p = tr(gl_FragCoord.xy);\n    vec3 col=vec3(.0);\n\n    p*=rot(time*.2);\n    p*=exp(-time*.1);\n    vec3 frac = fractal(p,tr(mouse),150.);\n    vec2 z = frac.xy;\n    float iter = frac.z;\n//  iter += time*.2;\n    col += iter;\n\n    col = pow(col,vec3(.85));\n    gl_FragColor = vec4(col,1.);\n}\n"}}